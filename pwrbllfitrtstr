import pandas as pd, re, csv

# === Config ===
REVERSE_INPUT = True   # Set to True if pwrbll.txt is newest→oldest
                      # Set to False if pwrbll.txt is oldest→newest

# === Load dataset ===
def load_draws(path="pwrbll.txt", reverse=False):
    with open(path) as f:
        lines = f.readlines()
    draws = []
    for line in lines:
        nums = re.findall(r"\b\d{1,2}\b", line)
        if len(nums) >= 5:
            draws.append([int(x) for x in nums[:5]])
    if reverse:
        draws.reverse()   # flip to chronological order
    return pd.DataFrame(draws)

df = load_draws("pwrbll.txt", reverse=REVERSE_INPUT)
total_pairs = len(df) - 1

# === Precompute variants ===
def precompute(df):
    pre = {}
    # Full combo sum of digits
    pre["full"] = [sum(int(d) for n in row for d in str(n)) for row in df.values]
    # 1’s place
    pre["ones"] = [sum(int(n) % 10 for n in row) for row in df.values]
    # 10’s place
    pre["tens"] = [sum(int(n) // 10 for n in row) for row in df.values]
    # Positional numbers
    for pos in range(5):
        pre[f"pos{pos+1}_num"] = [int(row[pos]) for row in df.values]
    # Positional digit sums
    for pos in range(5):
        pre[f"pos{pos+1}_sum"] = [sum(int(d) for d in str(row[pos])) for row in df.values]
    return pd.DataFrame(pre)

variants = precompute(df)

# === Helper: flatten digits for triple/repeat checks ===
def flatten_digits(nums):
    return [int(d) for n in nums for d in str(n)]

# === Runner for multiple filters ===
def run_filters(filters, out_path="filter_results.csv", append=False):
    mode = "a" if append else "w"
    results = []
    for name, seed_cond, combo_cond in filters:
        for variant in variants.columns:
            elim = 0
            for i in range(1, len(df)):
                seed_val = variants[variant].iloc[i-1]
                combo_val = variants[variant].iloc[i]
                seed_digits = flatten_digits(df.iloc[i-1])
                combo_digits = flatten_digits(df.iloc[i])
                if seed_cond(seed_val, seed_digits):
                    if combo_cond(combo_val, combo_digits):
                        elim += 1
            stat = f"{elim}/{total_pairs}"
            results.append([name, variant, elim, total_pairs, stat])
    # Save
    with open(out_path, mode, newline="") as f:
        writer = csv.writer(f)
        if not append:  # write header only once
            writer.writerow(["filter_name", "variant", "eliminated", "total", "stat"])
        writer.writerows(results)
    print(f"Results {'appended to' if append else 'saved to'} {out_path}")
    return results

# === Example filters ===
filters = [
    (
        "Seed=16 & Combo=Triple",
        lambda seed_val, seed_digits: seed_val == 16,
        lambda combo_val, combo_digits: any(combo_digits.count(d) >= 3 for d in set(combo_digits))
    )
]

# === Run ===
results = run_filters(filters, "filter_results.csv", append=False)
